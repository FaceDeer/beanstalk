--

---
--- constants
---
local bnst_pos={x=100,y=0,z=100}


local bnst_rotradius=6  --the radius the vines rotate around
local bnst_vineradius=3   --radius of each vine
local bnst_vtot=3         --total number of vines
local bnst_yper360=48     --y units per one 360 degree rotation of a vine

local bnst_material=minetest.get_content_id("default:cactus")
--local bnst_material=minetest.get_content_id("default:mossycobble")


--calculated constants
bnst_totradius=bnst_rotradius+bnst_vineradius+2 -- total radius = rotradius (radius vines circle around) + vine radius + 2 more for a space around the beanstalk (will be air)
bnst_min={x=bnst_pos.x-bnst_totradius, y=0, z=bnst_pos.z-bnst_totradius}
bnst_max={x=bnst_pos.x+bnst_totradius, y=5000, z=bnst_pos.z+bnst_totradius}
minetest.log("bs totradius="..bnst_totradius)

--grab content IDs -- You need these to efficiently access and set node data.  get_node() works, but is far slower
local c_air = minetest.get_content_id("air")

--
-- Aliases for map generator outputs
--


--minp is the min point of the chunk, maxp is the max point of the chunk
function beanstalk(minp, maxp, seed)
  --dont bother if we are not near the bean stalk
  if minp.x > bnst_max.x or maxp.x < bnst_min.x and
     minp.z > bnst_max.z or maxp.z < bnst_min.z  and
     minp.y > bnst_max.y or maxp.y < bnst_min.y then
    minetest.log("bs rejected: min=("..minp.x..","..minp.y..","..minp.z..") max=("..maxp.x..","..maxp.y..","..maxp.z..")")
    return --quit; otherwise, you'd have wasted resources
  end
  minetest.log("bs accepted: min=("..minp.x..","..minp.y..","..minp.z..") max=("..maxp.x..","..maxp.y..","..maxp.z..")")

  --easy reference to commonly used values
  local t1 = os.clock()
  local x1 = maxp.x
  local y1 = maxp.y
  local ymax=maxp.y
  local z1 = maxp.z
  local x0 = minp.x
  local y0 = minp.y
  local ymin=minp.y
  local z0 = minp.z

  print ("bs [beanstalk_gen] chunk minp ("..x0.." "..y0.." "..z0..")") --tell people you are generating a chunk

  --This actually initializes the LVM
  local vm, emin, emax = minetest.get_mapgen_object("voxelmanip")
  local area = VoxelArea:new{MinEdge=emin, MaxEdge=emax}
  local data = vm:get_data()

  local changedany=false
  local vinex={ } --just creates the variable for our array
  local vinez={ }

--cx=center point x
--cz=center point z
--rotr=rotational radius
--bsouterrad=bs outer radius
--vtot=number of vines
--vr=vine radius
--yper360=y units per 1 360 degree rotation of a vine.
--y=current height

  local y
  local a
  y=y1
  if y>bnst_max.y then
    y=bnst_max.y  --no need to start above the beanstalk
  end

  repeat
    minetest.log("bs y="..y.." bnst_vtot="..bnst_vtot)
    for v=0, bnst_vtot-1 do
      a=(360/bnst_vtot)*v+(360/bnst_yper360)*(y % bnst_yper360)
      vinex[v]=bnst_pos.x+bnst_rotradius*math.cos(a*math.pi/180)
      vinez[v]=bnst_pos.z+bnst_rotradius*math.sin(a*math.pi/180)
      minetest.log("  bs v="..v.." a="..a.." vinex[v]="..vinex[v].." vinez[v]="..vinez[v])
    end --for v
    for x=x0, x1 do
      --minetest.log("bs xloop x="..x)
      for z=z0, z1 do
        local vi = area:index(x, y, z) -- This accesses the node at a given position
        --minetest.log("bs   zloop z="..z)
        local changedthis=false
        local v=0
        repeat
          --minetest.log("bs     vloop v="..v)
          if math.sqrt((x-vinex[v])^2+(z-vinez[v])^2) <= bnst_vineradius then
            minetest.log("bs makevine  v="..v.." vinex[v]="..vinex[v].." vinez[v]="..vinez[v].." x="..x.." y="..y.." z="..z)
            data[vi]=bnst_material
            changedany=true
            changedthis=true
          end  --if math.sqrt((x-vine{v}.x)
          v=v+1
        until v > bnst_vtot-1 or changedthis==true
        if changedthis==false and (math.sqrt((x-bnst_pos.x)^2+(z-bnst_pos.z)^2) < bnst_totradius) and (y > bnst_pos.y-10) then
          --minetest.log("bs makeair x="..x.." y="..y.." z="..z)
          data[vi]=c_air
          changedany=true
        end --if changedthis=false
      end --for z
    end --for x
    y=y-1
  until y<bnst_pos.y or y<y0


  if changedany==true then
    -- Wrap things up and write back to map
    --send data back to voxelmanip
    vm:set_data(data)
    --calc lighting
    vm:set_lighting({day=0, night=0})
    vm:calc_lighting()
    --write it to world
    vm:write_to_map(data)
    --minetest.log(">>>saved")
  end --if changed write to map

  local chugent = math.ceil((os.clock() - t1) * 1000) --grab how long it took
  minetest.log("bs [beanstalk_gen] "..chugent.." ms") --tell people how long
end -- beanstalk


minetest.register_on_generated(beanstalk)

