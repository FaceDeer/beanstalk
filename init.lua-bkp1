--

---
--- constants
---
local bnst_pos={x=100,y=0,z=100}


local bnst_rotradius=2.5  --the radius the vines rotate around
local bnst_vineradius=2


--local nspawn_material=minetest.get_content_id("default:cactus")
local bnst_material=minetest.get_content_id("default:mossycobble")


--calculated constants
bnst_totradius=bnst_rotradius+bnst_vineradius+2 -- total radius = rotradius (radius vines circle around) + vine radius + 2 more for a space around the beanstalk (will be air)
bnst_min={x=bnst_pos.x-bnst_totradius, y=0, z=bnst_pos.z-bnst_totradius}
bnst_max={x=bnst_pos.x+bnst_totradius, y=5000, z=bnst_pos.z+bnst_totradius}

--nspawn_totrad=nspawn_radius+nspawn_steps
--local nspawn_min={x=nspawn_pos.x-nspawn_radius,
--                     y=nspawn_pos.y-nspawn_steps,
--                     z=nspawn_pos.z-nspawn_radius}
--local nspawn_max={x=nspawn_pos.x+nspawn_radius,
--                     y=nspawn_pos.y,
--                     z=nspawn_pos.z+nspawn_radius}

--print("**ZZ** nspawn_pos="..dump(nspawn_pos).." min="..dump(nspawn_min).." max="..dump(nspawn_max).." nspawn_stepmin="..dump(nspawn_stepmin).." nspawn_stepmax="..dump(nspawn_stepmax))

--grab content IDs -- You need these to efficiently access and set node data.  get_node() works, but is far slower
local c_air = minetest.get_content_id("air")

--
-- Aliases for map generator outputs
--


--minp is the min point of the chunk, maxp is the max point of the chunk
function beanstalk(minp, maxp, seed)
  --dont bother if we are not near the bean stalk
  if minp.x > bnst_max.x or maxp.x < bnst_min.x and
     minp.z > bnst_max.z or maxp.z < bnst_min.z  and
     minp.y > bnst_max.y or maxp.y < bnst_min.y then
    --print("rejected: min=("..minp.x..","..minp.y..","..minp.z..") max=("..maxp.x..","..maxp.y..","..maxp.z..")")
    return --quit; otherwise, you'd have wasted resources
  end 
  print("accepted: min=("..minp.x..","..minp.y..","..minp.z..") max=("..maxp.x..","..maxp.y..","..maxp.z..")")

  --easy reference to commonly used values
  local t1 = os.clock()
  local x1 = maxp.x
  local y1 = maxp.y
  local ymax=maxp.y
  local z1 = maxp.z
  local x0 = minp.x
  local y0 = minp.y
  local ymin=minp.y
  local z0 = minp.z

  print ("[beanstalk_gen] chunk minp ("..x0.." "..y0.." "..z0..")") --tell people you are generating a chunk

  --This actually initializes the LVM
  local vm, emin, emax = minetest.get_mapgen_object("voxelmanip")
  local area = VoxelArea:new{MinEdge=emin, MaxEdge=emax}
  local data = vm:get_data()

  local changed=false

  for z = z0, z1 do --
    for x = x0, x1 do --
      --calculate distance 2d
      local dist= math.sqrt((x-bnst_pos.x)^2+(z-bnst_pos.z)^2)
      --print("top ("..x.." y "..z..") dist="..dist.."nspawn_radius="..nspawn_radius.." nspawn_totrad="..nspawn_totrad)
      if dist <= bnst_totradius then -- x and z inside beanstalk TOTAL radius
        --print("--if1 ("..x.." y "..z..") dist="..dist.."nspawn_radius="..nspawn_radius.." nspawn_totrad="..nspawn_totrad)
        local y = y1
        if y>bnst_max.y then 
          y=bnst_max.y --no reason to loop more than max y
        end --if y>bnst_max.y
        repeat --loop through y values from top to bottom
          local vi = area:index(x, y, z) -- This accesses the node at a given position

          --is this the bean stalk?
          if dist<=bnst_rotradius then
            print("if2 ("..x.." "..y.." "..z..") dist="..dist.." bnst_rotradius="..bnst_rotradius.." bnst_totradius="..bnst_totradius)
            --inside bnst circle
            --we are moving top down 
            --print("   changed to material")
            data[vi]=bnst_material
            changed=true
          else
            --print("   changed to air")
            data[vi]=c_air
            changed=true
          end -- dist<bnst_totradius
          y=y-1
        until y < y0 or y < bnst_min.y --we quit at end of chunk, OR miny for beanstalk
      end -- if dist <= bnst_totradius  
    end -- for x loop
  end -- for z loop

  if changed==true then
    -- Wrap things up and write back to map
    --send data back to voxelmanip
    vm:set_data(data)
    --calc lighting
    vm:set_lighting({day=0, night=0})
    vm:calc_lighting()
    --write it to world
    vm:write_to_map(data)
    --print(">>>saved")
  end --if changed write to map

  local chugent = math.ceil((os.clock() - t1) * 1000) --grab how long it took
  print ("[newspawn_gen] "..chugent.." ms") --tell people how long
end -- beanstalk


  minetest.register_on_generated(beanstalk)

